create type "public"."match_request_status" as enum ('ACCEPTED', 'REFUSED', 'PENDING');

drop policy "Everyone can add to favorite" on "public"."favorite_users";

drop policy "User can update their own favorites" on "public"."favorite_users";

drop policy "Users can delete their own favorites" on "public"."favorite_users";

drop policy "Users can view their own favorites" on "public"."favorite_users";

drop policy "Users can insert their own profile." on "public"."profiles";

drop policy "Users can update their own profile." on "public"."profiles";

alter type "public"."manual_preference" rename to "manual_preference__old_version_to_be_dropped";

create type "public"."manual_preference" as enum ('LEFT_HANDED', 'RIGHT_HANDED');

create table "public"."complexes" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null
);


alter table "public"."complexes" enable row level security;

create table "public"."match_requests" (
    "match_id" bigint not null,
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "status" match_request_status not null default 'PENDING'::match_request_status
);


alter table "public"."match_requests" enable row level security;

create table "public"."matches" (
    "id" bigint generated by default as identity not null,
    "complex_id" bigint not null,
    "owner_id" uuid not null,
    "datetime" timestamp with time zone not null,
    "created_at" timestamp with time zone not null default now(),
    "duration" smallint not null,
    "level" smallint not null,
    "updated_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "booked_url" text
);


alter table "public"."matches" enable row level security;

alter table "public"."profiles" alter column manual_preference type "public"."manual_preference" using manual_preference::text::"public"."manual_preference";

drop type "public"."manual_preference__old_version_to_be_dropped";

alter table "public"."profiles" alter column "updated_at" set default (now() AT TIME ZONE 'utc'::text);

CREATE UNIQUE INDEX complexes_pkey ON public.complexes USING btree (id);

CREATE UNIQUE INDEX match_requests_pkey ON public.match_requests USING btree (match_id, user_id);

CREATE UNIQUE INDEX matches_pkey ON public.matches USING btree (id);

alter table "public"."complexes" add constraint "complexes_pkey" PRIMARY KEY using index "complexes_pkey";

alter table "public"."match_requests" add constraint "match_requests_pkey" PRIMARY KEY using index "match_requests_pkey";

alter table "public"."matches" add constraint "matches_pkey" PRIMARY KEY using index "matches_pkey";

alter table "public"."match_requests" add constraint "public_match_requests_match_id_fkey" FOREIGN KEY (match_id) REFERENCES matches(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."match_requests" validate constraint "public_match_requests_match_id_fkey";

alter table "public"."match_requests" add constraint "public_match_requests_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."match_requests" validate constraint "public_match_requests_user_id_fkey";

alter table "public"."matches" add constraint "public_matches_complex_id_fkey" FOREIGN KEY (complex_id) REFERENCES complexes(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."matches" validate constraint "public_matches_complex_id_fkey";

alter table "public"."matches" add constraint "public_matches_owner_id_fkey" FOREIGN KEY (owner_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."matches" validate constraint "public_matches_owner_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_match_request_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$DECLARE
  count integer;
BEGIN
  SELECT count(*) INTO count
  FROM match_requests
  WHERE match_requests.match_id = NEW.match_id AND match_requests.STATUS = 'ACCEPTED'::match_request_status;

  IF NEW.STATUS = 'ACCEPTED' AND count >= 3 THEN
    RAISE EXCEPTION 'MATCH_FULL';
  END IF;

  return NEW;
END;$function$
;

grant delete on table "public"."complexes" to "anon";

grant insert on table "public"."complexes" to "anon";

grant references on table "public"."complexes" to "anon";

grant select on table "public"."complexes" to "anon";

grant trigger on table "public"."complexes" to "anon";

grant truncate on table "public"."complexes" to "anon";

grant update on table "public"."complexes" to "anon";

grant delete on table "public"."complexes" to "authenticated";

grant insert on table "public"."complexes" to "authenticated";

grant references on table "public"."complexes" to "authenticated";

grant select on table "public"."complexes" to "authenticated";

grant trigger on table "public"."complexes" to "authenticated";

grant truncate on table "public"."complexes" to "authenticated";

grant update on table "public"."complexes" to "authenticated";

grant delete on table "public"."complexes" to "service_role";

grant insert on table "public"."complexes" to "service_role";

grant references on table "public"."complexes" to "service_role";

grant select on table "public"."complexes" to "service_role";

grant trigger on table "public"."complexes" to "service_role";

grant truncate on table "public"."complexes" to "service_role";

grant update on table "public"."complexes" to "service_role";

grant delete on table "public"."match_requests" to "anon";

grant insert on table "public"."match_requests" to "anon";

grant references on table "public"."match_requests" to "anon";

grant select on table "public"."match_requests" to "anon";

grant trigger on table "public"."match_requests" to "anon";

grant truncate on table "public"."match_requests" to "anon";

grant update on table "public"."match_requests" to "anon";

grant delete on table "public"."match_requests" to "authenticated";

grant insert on table "public"."match_requests" to "authenticated";

grant references on table "public"."match_requests" to "authenticated";

grant select on table "public"."match_requests" to "authenticated";

grant trigger on table "public"."match_requests" to "authenticated";

grant truncate on table "public"."match_requests" to "authenticated";

grant update on table "public"."match_requests" to "authenticated";

grant delete on table "public"."match_requests" to "service_role";

grant insert on table "public"."match_requests" to "service_role";

grant references on table "public"."match_requests" to "service_role";

grant select on table "public"."match_requests" to "service_role";

grant trigger on table "public"."match_requests" to "service_role";

grant truncate on table "public"."match_requests" to "service_role";

grant update on table "public"."match_requests" to "service_role";

grant delete on table "public"."matches" to "anon";

grant insert on table "public"."matches" to "anon";

grant references on table "public"."matches" to "anon";

grant select on table "public"."matches" to "anon";

grant trigger on table "public"."matches" to "anon";

grant truncate on table "public"."matches" to "anon";

grant update on table "public"."matches" to "anon";

grant delete on table "public"."matches" to "authenticated";

grant insert on table "public"."matches" to "authenticated";

grant references on table "public"."matches" to "authenticated";

grant select on table "public"."matches" to "authenticated";

grant trigger on table "public"."matches" to "authenticated";

grant truncate on table "public"."matches" to "authenticated";

grant update on table "public"."matches" to "authenticated";

grant delete on table "public"."matches" to "service_role";

grant insert on table "public"."matches" to "service_role";

grant references on table "public"."matches" to "service_role";

grant select on table "public"."matches" to "service_role";

grant trigger on table "public"."matches" to "service_role";

grant truncate on table "public"."matches" to "service_role";

grant update on table "public"."matches" to "service_role";

create policy "Complexes are viewable by everyone"
on "public"."complexes"
as permissive
for select
to public
using (true);


create policy "Users can add to favorite"
on "public"."favorite_users"
as permissive
for insert
to authenticated
with check (true);


create policy "Captains can accept or refuse pending request"
on "public"."match_requests"
as permissive
for update
to authenticated
using (((status = 'PENDING'::match_request_status) AND (match_id IN ( SELECT matches.id
   FROM matches
  WHERE (matches.owner_id = auth.uid())))))
with check ((match_id IN ( SELECT matches.id
   FROM matches
  WHERE (matches.owner_id = auth.uid()))));


create policy "Requests are viewable by captains or owners"
on "public"."match_requests"
as permissive
for select
to authenticated
using (((user_id = auth.uid()) OR (match_id IN ( SELECT matches.id
   FROM matches
  WHERE (matches.owner_id = auth.uid())))));


create policy "Users can delete their own requests"
on "public"."match_requests"
as permissive
for delete
to authenticated
using ((auth.uid() = user_id));


create policy "Users can requests match (captains can't)"
on "public"."match_requests"
as permissive
for insert
to authenticated
with check ((NOT (user_id IN ( SELECT matches.owner_id
   FROM matches
  WHERE (matches.id = match_requests.match_id)))));


create policy "Matches are viewable by everyone"
on "public"."matches"
as permissive
for select
to public
using (true);


create policy "Users can create matches"
on "public"."matches"
as permissive
for insert
to authenticated
with check (true);


create policy "Users can delete their own matches"
on "public"."matches"
as permissive
for delete
to authenticated
using ((auth.uid() = owner_id));


create policy "Users can update their own matches"
on "public"."matches"
as permissive
for update
to authenticated
using ((auth.uid() = owner_id));


create policy "User can update their own favorites"
on "public"."favorite_users"
as permissive
for update
to authenticated
using ((auth.uid() = user_id));


create policy "Users can delete their own favorites"
on "public"."favorite_users"
as permissive
for delete
to authenticated
using ((auth.uid() = user_id));


create policy "Users can view their own favorites"
on "public"."favorite_users"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "Users can insert their own profile."
on "public"."profiles"
as permissive
for insert
to authenticated
with check ((auth.uid() = id));


create policy "Users can update their own profile."
on "public"."profiles"
as permissive
for update
to authenticated
using ((auth.uid() = id));


CREATE TRIGGER limit_match_requests_trigger BEFORE INSERT OR UPDATE ON public.match_requests FOR EACH ROW EXECUTE FUNCTION check_match_request_count();



